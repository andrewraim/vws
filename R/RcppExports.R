# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' Categorical Distribution
#'
#' @name Categorical
#' @export
r_categ <- function(n, p, log = FALSE, one_based = FALSE) {
    .Call(`_vws_r_categ_rcpp`, n, p, log, one_based)
}

#' Gumbel Distribution
#'
#' Functions for the Gumbel distribution
#'
#' @param n Number of draws
#' @param x Vector of quantiles
#' @param p Vector of probabilities
#' @param q Vector of quantiles
#' @param mu Location parameter
#' @param sigma Scale parameter
#' @param lower Logical; if `TRUE` (default), probabilities are
#' \eqn{P[X \leq x]} otherwise, \eqn{P[X > x]}.
#' @param log Logical; if `TRUE`, probabilities p are given as \eqn{log(p)}
#'
#' @return A vector of draws
#'
#' @name Gumbel
#' @export
r_gumbel <- function(n, mu = 0, sigma = 1) {
    .Call(`_vws_r_gumbel_rcpp`, n, mu, sigma)
}

#' @name Gumbel
#' @export
d_gumbel <- function(x, mu = 0, sigma = 1, log = FALSE) {
    .Call(`_vws_d_gumbel_rcpp`, x, mu, sigma, log)
}

#' @name Gumbel
#' @export
p_gumbel <- function(q, mu = 0, sigma = 1, lower = TRUE, log = FALSE) {
    .Call(`_vws_p_gumbel_rcpp`, q, mu, sigma, lower, log)
}

#' @name Gumbel
#' @export
q_gumbel <- function(p, mu = 0, sigma = 1, lower = TRUE, log = FALSE) {
    .Call(`_vws_q_gumbel_rcpp`, p, mu, sigma, lower, log)
}

#' Inverse Gamma distribution
#'
#' @param n Number of draws.
#' @param x Vector of quantiles.
#' @param q Vector of quantiles.
#' @param p Vector of probabilities.
#' @param a Shape parameter.
#' @param b Rate parameter.
#' @param lower logical; if TRUE (default), probabilities are
#' \eqn{P(X \leq x)}; otherwise, \eqn{P(X > x)}.
#' @param log If `TRUE`, return densities and probabilities on the log-scale.
#'
#' @return
#' `d_invgamma` computes the density, `r_invgamma` generates random deviates,
#' `p_invgamma` computes the CDF, and `q_invgamma` computes quantiles.
#'
#' @details
#' Note that `Rcpp::*gamma` and `R::*gamma` functions are both parameterized
#' by a scale parameter, which is the inverse of the rate.
#'
#' @name InverseGamma
r_invgamma <- function(n, a, b) {
    .Call(`_vws_r_invgamma_rcpp`, n, a, b)
}

#' @name InverseGamma
#' @export
d_invgamma <- function(x, a, b, log = FALSE) {
    .Call(`_vws_d_invgamma_rcpp`, x, a, b, log)
}

#' @name InverseGamma
#' @export
p_invgamma <- function(q, a, b, lower = TRUE, log = FALSE) {
    .Call(`_vws_p_invgamma_rcpp`, q, a, b, lower, log)
}

#' @name InverseGamma
#' @export
q_invgamma <- function(p, a, b, lower = TRUE, log = FALSE) {
    .Call(`_vws_q_invgamma_rcpp`, p, a, b, lower, log)
}

#' Log-Sum-Exp
#'
#' Compute `log(sum(exp(x)))` in a more stable way.
#'
#' @param x A numeric vector
#' @param y A numeric vector
#'
#' @details Computed using the method described by user Ben in StackExchange
#' thread \url{https://stats.stackexchange.com/questions/381936/vectorised-computation-of-logsumexp}.
#'
#' The function `log_sub2_exp` expects that each element of `x` is
#' larger than or equal to its corresponding element in `y`. Otherwise,
#' `NaN` will be returned with a warning.
#'
#' The function `log_sub2_exp_signed` can handle inputs where elements of
#' `x` are smaller than corresponding elements of `y`. The return
#' value `modulus` contains `log(abs(exp(x) - exp(y)))`, and
#' `sign` contains the sign of `exp(x) - exp(y)`. Therefore, the
#' difference on the original scale can be reconstituted as
#' `sign * exp(modulus)`.
#'
#' @examples
#' pi = 1:6 / sum(1:6)
#' x = log(2*pi)
#' log(sum(exp(x)))
#' log_sum_exp(x)
#'
#' # Result should be 0
#' x = c(-Inf -Inf, 0)
#' log_sum_exp(x)
#'
#' # Result should be -Inf
#' x = c(-Inf -Inf, -Inf)
#' log_sum_exp(x)
#'
#' # Result should be -Inf
#' x = c(-Inf -Inf, Inf)
#' log_sum_exp(x)
#'
#' # Result should be 5 on the original scale
#' out = log_add2_exp(log(3), log(2))
#' exp(out)
#'
#' # Result should be 7 on the original scale
#' out = log_sub2_exp(log(12), log(5))
#' exp(out)
#'
#' # Results should be 7 and -7 on the original scale, respectively
#' out1 = log_sub2_exp_signed(log(12), log(5))
#' out2 = log_sub2_exp_signed(log(5), log(12))
#' out1$sign * exp(out1$modulus)
#' out2$sign * exp(out2$modulus)
#'
#' @name log_sum_exp
#' @export
log_sum_exp <- function(x) {
    .Call(`_vws_log_sum_exp_rcpp`, x)
}

#' @name log_sum_exp
#' @export
log_sum_exp_mat <- function(x) {
    .Call(`_vws_log_sum_exp_mat_rcpp`, x)
}

#' @name log_sum_exp
#' @export
log_add2_exp <- function(x, y) {
    .Call(`_vws_log_add2_exp_rcpp`, x, y)
}

#' @name log_sum_exp
#' @export
log_sub2_exp <- function(x, y) {
    .Call(`_vws_log_sub2_exp_rcpp`, x, y)
}

#' Optimize Hybrid
#'
#' @param f TBD
#' @param init TBD
#' @param lower TBD
#' @param upper TBD
#' @param maximize TBD
#' @param maxiter TBD
#'
#' @export
optimize_hybrid <- function(f, init, lower, upper, maximize, maxiter = 100000L) {
    .Call(`_vws_optimize_hybrid_rcpp`, f, init, lower, upper, maximize, maxiter)
}

#' Rectangular transformation
#'
#' A transformation from Euclidean to a rectangle in \eqn{\mathbb{R}^n}, and
#' its inverse transformation.
#'
#' @param x A point in \eqn{\mathbb{R}^{d}}.
#' @param z A point in the rectangle \eqn{[a_1,b_1] \times \cdots \times [a_d,b_d]}.
#' @param a A vector \eqn{(a_1, \ldots, a_d)}, Elements may be `-Inf`.
#' @param b A vector \eqn{(b_1, \ldots, b_d)}, Elements may be `Inf`.
#'
#' @examples
#' x = seq(-1, 1, length.out = 3)
#' a = rep(0, 3)
#' b = rep(1, 3)
#' z = inv_rect(x, a, b)
#' rect(z, a, b)
#'
#' a = c(-Inf, 0, -Inf)
#' b = c(Inf, 1, Inf)
#' z = inv_rect(x, a, b)
#' rect(z, a, b)
#'
#' @name rect
#' @export
rect <- function(z, a, b) {
    .Call(`_vws_rect_rcpp`, z, a, b)
}

#' @name rect
#' @export
inv_rect <- function(x, a, b) {
    .Call(`_vws_inv_rect_rcpp`, x, a, b)
}

