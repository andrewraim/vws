# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' Categorical Distribution
#'
#' Draw variates from a categorical distribution.
#'
#' @param n Number of desired draws.
#' @param p Vector of \eqn{k} probabilities for distribution.
#' @param log logical; if `TRUE`, interpret `p` as being specified on the
#' log-scale as `log(p)`. Otherwise, interpret `p` as being specified on the
#' original probability scale.
#' @param one_based logical; if `TRUE`, assume a categorical distribution
#' with support \eqn{\{ 1, \ldots, k \}}. Otherwise, assume support
#' \eqn{\{ 0, \ldots, k - 1 \}}.
#'
#' @return A vector of \eqn{n} draws.
#'
#' @examples
#' p = c(0.1, 0.2, 0.3, 0.4)
#' lp = log(p)
#'
#' set.seed(1234)
#' r_categ(50, p, log = FALSE, one_based = FALSE)
#' r_categ(50, p, log = FALSE, one_based = TRUE)
#'
#' set.seed(1234)
#' r_categ(50, lp, log = TRUE, one_based = FALSE)
#' r_categ(50, lp, log = TRUE, one_based = TRUE)
#'
#' @name Categorical
#' @export
r_categ <- function(n, p, log = FALSE, one_based = FALSE) {
    .Call(`_vws_r_categ_rcpp`, n, p, log, one_based)
}

#' Truncated Gamma Distribution
#'
#' Functions for the Truncated Gamma distribution parameterized by shape and
#' rate, whose density is
#' \deqn{
#' f(x \mid a, b) =
#' \frac{
#' b^a
#' }{
#' \Gamma(a)
#' }
#' x^{-a-1} e^{-b / x} \textrm{I}(x \geq 0)
#' }
#'
#' @param n Number of draws.
#' @param x Vector; argument of density.
#' @param q Vector; argument of cumulative distribution function.
#' @param p Vector; argument of quantile function.
#' @param shape Shape parameter.
#' @param rate Rate parameter.
#' @param a lower limit of support.
#' @param b upper limit of support.
#' @param lower logical; if `TRUE` (default), probabilities are
#' \eqn{P(X \leq x)}; otherwise, \eqn{P(X > x)}.
#' @param log If `TRUE`, return densities and probabilities on the log-scale.
#'
#' @return
#' `d_gamma_trunc` computes the density, `r_gamma_trunc` generates random
#' deviates, `p_gamma_trunc` computes the CDF, and `q_gamma_trunc` computes
#' quantiles.
#'
#' @examples
#' shape = 10
#' rate = 5
#' a = 2
#' b = 5
#' x = r_gamma_trunc(100000, shape, rate, a, b)
#' xx = seq(a, b, length.out = 100)
#'
#' plot(density(x))
#' lines(xx, d_gamma_trunc(xx, shape, rate, a, b), lty = 2, col = "blue", lwd = 2)
#'
#' plot(ecdf(x))
#' lines(xx, p_gamma_trunc(xx, shape, rate, a, b), lty = 2, col = "blue", lwd = 2)
#'
#' pp = seq(0, 1, length.out = 102) |> head(-1) |> tail(-1)
#' qq = quantile(x, probs = pp)
#' plot(pp, qq)
#' lines(pp, q_gamma_trunc(pp, shape, rate, a, b), lty = 2, col = "blue", lwd = 2)
#'
#' @name GammaTrunc
#' @export
r_gamma_trunc <- function(n, shape, rate, a, b) {
    .Call(`_vws_r_gamma_trunc_rcpp`, n, shape, rate, a, b)
}

#' @name GammaTrunc
#' @export
d_gamma_trunc <- function(x, shape, rate, a, b, log = FALSE) {
    .Call(`_vws_d_gamma_trunc_rcpp`, x, shape, rate, a, b, log)
}

#' @name GammaTrunc
#' @export
p_gamma_trunc <- function(q, shape, rate, a, b, lower = TRUE, log = FALSE) {
    .Call(`_vws_p_gamma_trunc_rcpp`, q, shape, rate, a, b, lower, log)
}

#' @name GammaTrunc
#' @export
q_gamma_trunc <- function(p, shape, rate, a, b, lower = TRUE, log = FALSE) {
    .Call(`_vws_q_gamma_trunc_rcpp`, p, shape, rate, a, b, lower, log)
}

#' Gumbel Distribution
#'
#' Functions for the Gumbel distribution with density
#' \deqn{
#' f(x \mid \mu, \sigma) =
#' \frac{1}{\sigma}
#' \exp\{ -\{ (x - \mu) / \sigma + e^{-(x - \mu) / \sigma} \} \}
#' }
#'
#' @param n Number of draws.
#' @param x Vector; argument of density.
#' @param p Vector; argument of cumulative distribution function.
#' @param q Vector; argument of quantile function.
#' @param mu Location parameter.
#' @param sigma Scale parameter.
#' @param lower Logical; if `TRUE` (default), probabilities are
#' \eqn{P[X \leq x]} otherwise, \eqn{P[X > x]}.
#' @param log Logical; if `TRUE`, probabilities p are given as \eqn{log(p)}
#'
#' @return
#' `d_gumbel` computes the density, `r_gumbel` generates random deviates,
#' `p_gumbel` computes the CDF, and `q_gumbel` computes quantiles.
#'
#' @examples
#' mu = 1
#' sigma = 2
#' x = r_gumbel(100000, mu, sigma)
#' xx = seq(min(x), max(x), length.out = 100)
#'
#' plot(density(x))
#' lines(xx, d_gumbel(xx, mu, sigma), lty = 2, col = "blue", lwd = 2)
#'
#' plot(ecdf(x))
#' lines(xx, p_gumbel(xx, mu, sigma), lty = 2, col = "blue", lwd = 2)
#'
#' pp = seq(0, 1, length.out = 102) |> head(-1) |> tail(-1)
#' qq = quantile(x, probs = pp)
#' plot(pp, qq)
#' lines(pp, q_gumbel(pp, mu, sigma), lty = 2, col = "blue", lwd = 2)
#'
#' @name Gumbel
#' @export
r_gumbel <- function(n, mu = 0, sigma = 1) {
    .Call(`_vws_r_gumbel_rcpp`, n, mu, sigma)
}

#' @name Gumbel
#' @export
d_gumbel <- function(x, mu = 0, sigma = 1, log = FALSE) {
    .Call(`_vws_d_gumbel_rcpp`, x, mu, sigma, log)
}

#' @name Gumbel
#' @export
p_gumbel <- function(q, mu = 0, sigma = 1, lower = TRUE, log = FALSE) {
    .Call(`_vws_p_gumbel_rcpp`, q, mu, sigma, lower, log)
}

#' @name Gumbel
#' @export
q_gumbel <- function(p, mu = 0, sigma = 1, lower = TRUE, log = FALSE) {
    .Call(`_vws_q_gumbel_rcpp`, p, mu, sigma, lower, log)
}

#' Inverse Gamma Distribution
#'
#' Functions for the Inverse Gamma distribution parameterized by shape and
#' rate, whose density is
#' \deqn{
#' f(x \mid a, b) =
#' \frac{
#' b^a
#' }{
#' \Gamma(a)
#' }
#' x^{a-1} e^{-b x} \textrm{I}(x \geq 0)
#' }
#'
#' @param n Number of draws.
#' @param x Vector; argument of density.
#' @param q Vector; argument of cumulative distribution function.
#' @param p Vector; argument of quantile function.
#' @param a Shape parameter.
#' @param b Rate parameter.
#' @param lower logical; if `TRUE` (default), probabilities are
#' \eqn{P(X \leq x)}; otherwise, \eqn{P(X > x)}.
#' @param log If `TRUE`, return densities and probabilities on the log-scale.
#'
#' @return
#' `d_invgamma` computes the density, `r_invgamma` generates random deviates,
#' `p_invgamma` computes the CDF, and `q_invgamma` computes quantiles.
#'
#' @examples
#' a = 10
#' b = 5
#' x = r_invgamma(100000, a, b)
#' xx = seq(0, 3, length.out = 100)
#'
#' plot(density(x))
#' lines(xx, d_invgamma(xx, a, b), lty = 2, col = "blue", lwd = 2)
#'
#' plot(ecdf(x))
#' lines(xx, p_invgamma(xx, a, b), lty = 2, col = "blue", lwd = 2)
#'
#' pp = seq(0, 1, length.out = 102) |> head(-1) |> tail(-1)
#' qq = quantile(x, probs = pp)
#' plot(pp, qq)
#' lines(pp, q_invgamma(pp, a, b), lty = 2, col = "blue", lwd = 2)
#'
#' @name InverseGamma
#' @export
r_invgamma <- function(n, a, b) {
    .Call(`_vws_r_invgamma_rcpp`, n, a, b)
}

#' @name InverseGamma
#' @export
d_invgamma <- function(x, a, b, log = FALSE) {
    .Call(`_vws_d_invgamma_rcpp`, x, a, b, log)
}

#' @name InverseGamma
#' @export
p_invgamma <- function(q, a, b, lower = TRUE, log = FALSE) {
    .Call(`_vws_p_invgamma_rcpp`, q, a, b, lower, log)
}

#' @name InverseGamma
#' @export
q_invgamma <- function(p, a, b, lower = TRUE, log = FALSE) {
    .Call(`_vws_q_invgamma_rcpp`, p, a, b, lower, log)
}

#' Log-Sum-Exp
#'
#' Compute `log(sum(exp(x)))` in a more stable way.
#'
#' @param x A numeric vector
#' @param y A numeric vector
#'
#' @details Computed using the method described by user Ben in StackExchange
#' thread \url{https://stats.stackexchange.com/questions/381936/vectorised-computation-of-logsumexp}.
#'
#' The function `log_sub2_exp` expects that each element of `x` is
#' larger than or equal to its corresponding element in `y`. Otherwise,
#' `NaN` will be returned with a warning.
#'
#' @examples
#' pi = 1:6 / sum(1:6)
#' x = log(2*pi)
#' log(sum(exp(x)))
#' log_sum_exp(x)
#'
#' # Result should be 0
#' x = c(-Inf -Inf, 0)
#' log_sum_exp(x)
#'
#' # Result should be -Inf
#' x = c(-Inf -Inf, -Inf)
#' log_sum_exp(x)
#'
#' # Result should be Inf
#' x = c(-Inf -Inf, Inf)
#' log_sum_exp(x)
#'
#' # Result should be 5 on the original scale
#' out = log_add2_exp(log(3), log(2))
#' exp(out)
#'
#' # Result should be 7 on the original scale
#' out = log_sub2_exp(log(12), log(5))
#' exp(out)
#'
#' @name log_sum_exp
#' @export
log_sum_exp <- function(x) {
    .Call(`_vws_log_sum_exp_rcpp`, x)
}

#' @name log_sum_exp
#' @export
log_sum_exp_mat <- function(x) {
    .Call(`_vws_log_sum_exp_mat_rcpp`, x)
}

#' @name log_sum_exp
#' @export
log_add2_exp <- function(x, y) {
    .Call(`_vws_log_add2_exp_rcpp`, x, y)
}

#' @name log_sum_exp
#' @export
log_sub2_exp <- function(x, y) {
    .Call(`_vws_log_sub2_exp_rcpp`, x, y)
}

#' Hybrid Univariate Optimization
#'
#' Use Brent's method if a bounded search interval is specified. Otherwise use
#' BFGS method.
#'
#' @param f Objective function. Should take a scalar as an argument.
#' @param init Initial value for optimization variable.
#' @param lower Lower bound for search; may be \eqn{-\infty}.
#' @param upper Upper bound for search; may be \eqn{+\infty}.
#' @param maximize logical; if `TRUE`, optimization will be a maximization.
#' Otherwise, it will be a minimization.
#' @param maxiter Maximum number of iterations.
#'
#' @returns
#' \item{par}{Value of optimization variable.}
#' \item{value}{Value of optimization function.}
#' \item{method}{Description of result.}
#' \item{status}{Status code from BFGS or `0` otherwise.}
#'
#' @examples
#' f = function(x) { x^2 }
#' optimize_hybrid(f, init = 0, lower = -1, upper = 2, maximize = FALSE)
#' optimize_hybrid(f, init = 0, lower = -1, upper = Inf, maximize = FALSE)
#' optimize_hybrid(f, init = 0, lower = -Inf, upper = 1, maximize = FALSE)
#' optimize_hybrid(f, init = 0, lower = 0, upper = Inf, maximize = FALSE)
#' optimize_hybrid(f, init = 0, lower = -Inf, upper = 0, maximize = FALSE)
#'
#' f = function(x) { 1 - x^2 }
#' optimize_hybrid(f, init = 0, lower = -1, upper = 1, maximize = TRUE)
#' optimize_hybrid(f, init = 0, lower = -1, upper = 0, maximize = TRUE)
#' optimize_hybrid(f, init = 0, lower = 0, upper = 1, maximize = TRUE)
#'
#' @export
optimize_hybrid <- function(f, init, lower, upper, maximize = FALSE, maxiter = 10000L) {
    .Call(`_vws_optimize_hybrid_rcpp`, f, init, lower, upper, maximize, maxiter)
}

#' Rectangular transformation
#'
#' A transformation from Euclidean to a rectangle in \eqn{\mathbb{R}^n}, and
#' its inverse transformation.
#'
#' @param x A point in \eqn{\mathbb{R}^{d}}.
#' @param z A point in the rectangle \eqn{[a_1,b_1] \times \cdots \times [a_d,b_d]}.
#' @param a A vector \eqn{(a_1, \ldots, a_d)}, Elements may be `-Inf`.
#' @param b A vector \eqn{(b_1, \ldots, b_d)}, Elements may be `+Inf`.
#'
#' @examples
#' n = 20
#' x = seq(-5, 5, length.out = n)
#'
#' # Transform x to the interval [-1, 1]
#' a = rep(-1, n)
#' b = rep(+1, n)
#' z = inv_rect(x, a, b)
#' print(z)
#' xx = rect(z, a, b)
#' stopifnot(all(abs(x - xx) < 1e-8))
#'
#' # Transform x to the interval [-Inf, 1]
#' a = rep(-Inf, n)
#' b = rep(+1, n)
#' z = inv_rect(x, a, b)
#' print(z)
#' xx = rect(z, a, b)
#' stopifnot(all(abs(x - xx) < 1e-8))
#'
#' # Transform x to the interval [-1, Inf]
#' a = rep(-1, n)
#' b = rep(+Inf, n)
#' z = inv_rect(x, a, b)
#' print(z)
#' xx = rect(z, a, b)
#' stopifnot(all(abs(x - xx) < 1e-8))
#'
#' # Transform x to the interval [-Inf, Inf]
#' a = rep(-Inf, n)
#' b = rep(+Inf, n)
#' z = inv_rect(x, a, b)
#' print(z)
#' xx = rect(z, a, b)
#' stopifnot(all(abs(x - xx) < 1e-8))
#'
#' @name rect
#' @export
rect <- function(z, a, b) {
    .Call(`_vws_rect_rcpp`, z, a, b)
}

#' @name rect
#' @export
inv_rect <- function(x, a, b) {
    .Call(`_vws_inv_rect_rcpp`, x, a, b)
}

rejection_int_rcpp <- function(n, lo, hi, w, d_base, p_base, q_base, s_base, N, tol, control) {
    .Call(`_vws_rejection_int_rcpp`, n, lo, hi, w, d_base, p_base, q_base, s_base, N, tol, control)
}

rejection_numeric_rcpp <- function(n, lo, hi, w, d_base, p_base, q_base, s_base, N, tol, control) {
    .Call(`_vws_rejection_numeric_rcpp`, n, lo, hi, w, d_base, p_base, q_base, s_base, N, tol, control)
}

#' Truncated Exponential
#'
#' Functions for the truncated exponential distribution with density
#' \deqn{
#' f(x \mid \kappa, a, b) =
#' \frac{
#' \kappa e^{\kappa x}
#' }{
#' e^{\kappa b} - e^{\kappa a}
#' } \textrm{I}(a \leq x \leq b)
#' }
#'
#' @param n Number of desired draws.
#' @param x Vector; argument of density.
#' @param p Vector; argument of cumulative distribution function.
#' @param q Vector; argument of quantile function.
#' @param s Vector; argument of moment-generating function.
#' @param kappa Parameter of distribution.
#' @param a Lower limit of integral.
#' @param b Upper limit of integral.
#' @param lo Lower limit of support.
#' @param hi Upper limit of support.
#' @param log logical; if `TRUE`, probabilities are interpreted on the
#' log-scale. Otherwise, probabilities are interpreted on the original scale.
#' @param lower logical; if `TRUE`, probabilities are \eqn{P(X \leq x)};
#' otherwise \eqn{P(X > x)}.
#'
#' @return
#' \item{n_texp}{Normalizing constant.}
#' \item{integrate_texp}{Compute integral of density over an interval.}
#' \item{d_texp}{Compute density.}
#' \item{p_texp}{Compute cumulative probabilities.}
#' \item{q_texp}{Compute quantiles.}
#' \item{r_texp}{Generate variates.}
#' \item{mgf_texp}{Compute moment generating function.}
#'
#' @examples
#' set.seed(1234)
#' kappa = 2
#' lo = -0.5
#' hi = +0.5
#'
#' x = r_texp(100000, kappa, lo, hi)
#' xx = seq(min(x), max(x), length.out = 100)
#'
#' hist(x, probability = TRUE)
#' lines(xx, d_texp(xx, kappa, lo, hi), lty = 2, col = "blue", lwd = 2)
#'
#' plot(ecdf(x))
#' lines(xx, p_texp(xx, kappa, lo, hi), lty = 2, col = "blue", lwd = 2)
#'
#' pp = seq(0, 1, length.out = 102) |> head(-1) |> tail(-1)
#' qq = quantile(x, probs = pp)
#' plot(pp, qq)
#' lines(pp, q_texp(pp, kappa, lo, hi), lty = 2, col = "blue", lwd = 2)
#'
#' n_texp(kappa, lo, hi)
#' n_texp(kappa, lo, hi, log = TRUE)
#'
#' integrate_texp(0, hi, kappa, lo, hi)
#' integrate_texp(0, hi, kappa, lo, hi, log = TRUE)
#'
#' mgf_texp(0, kappa, lo, hi)
#' mgf_texp(0, kappa, lo, hi, log = TRUE)
#' mgf_texp(0.5, kappa, lo, hi)
#' mgf_texp(0.5, kappa, lo, hi, log = TRUE)
#'
#' @name TExp
#' @export
n_texp <- function(kappa, lo, hi, log = FALSE) {
    .Call(`_vws_n_texp_rcpp`, kappa, lo, hi, log)
}

#' @name TExp
#' @export
integrate_texp <- function(a, b, kappa, lo, hi, log = FALSE) {
    .Call(`_vws_integrate_texp_rcpp`, a, b, kappa, lo, hi, log)
}

#' @name TExp
#' @export
d_texp <- function(x, kappa, lo, hi, log = FALSE) {
    .Call(`_vws_d_texp_rcpp`, x, kappa, lo, hi, log)
}

#' @name TExp
#' @export
p_texp <- function(q, kappa, lo, hi, lower = TRUE, log = FALSE) {
    .Call(`_vws_p_texp_rcpp`, q, kappa, lo, hi, lower, log)
}

#' @name TExp
#' @export
q_texp <- function(p, kappa, lo, hi, lower = TRUE, log = FALSE) {
    .Call(`_vws_q_texp_rcpp`, p, kappa, lo, hi, lower, log)
}

#' @name TExp
#' @export
r_texp <- function(n, kappa, lo, hi) {
    .Call(`_vws_r_texp_rcpp`, n, kappa, lo, hi)
}

#' @name TExp
#' @export
mgf_texp <- function(s, kappa, lo, hi, log = FALSE) {
    .Call(`_vws_mgf_texp_rcpp`, s, kappa, lo, hi, log)
}

#' Uniform Distribution
#'
#' Moment-generating function (MGF) for the \eqn{Uniform(a, b)} distribution.
#'
#' @param s Vector; argument of MGF.
#' @param lo Lower bound \eqn{a} of distribution.
#' @param hi Lower bound \eqn{b} of distribution.
#' @param log logical; if `TRUE`, return value on log-scale. Otherwise return
#' value on original scale.
#'
#' @return Value of MGF.
#'
#' @examples
#' mgf_unif(0, lo = 0, hi = 1, log = TRUE)
#' mgf_unif(-0.25, lo = 0, hi = 1, log = TRUE)
#' mgf_unif(-0.25, lo = 0, hi = 1, log = FALSE)
#' mgf_unif(+0.25, lo = 0, hi = 1, log = TRUE)
#'
#' @name Uniform
#' @export
mgf_unif <- function(s, lo, hi, log = FALSE) {
    .Call(`_vws_mgf_unif_rcpp`, s, lo, hi, log)
}

