---
title: "Vertical Weighted Strips in R"
author:
  - name: Andrew M. Raim^[Corresponding author <andrew.raim@gmail.com>.
      Center for Statistical Research & Methodology,
      U.S. Census Bureau,
      Washington, DC, 20233, U.S.A.
      **Disclaimer**`:` This document is released to inform interested parties
      of ongoing research and to encourage discussion of work in progress. Any
      views expressed are those of the authors and not those of the U.S. Census
      Bureau.]
    email: andrew.raim@gmail.com
  - name: James A. Livsey
  - name: Kyle M. Irimata
affiliations:
  - name: U.S. Census Bureau
    department: Center for Statistical Research and Methodology
    address: 4600 Silver Hill Road
    city: Washington DC
    country: U.S.A.
format:
  pdf:
    toc: true
    number-sections: true
    colorlinks: true
    link-citations: true
    prompt: false
    template-partials: 
      - title.tex
    include-in-header:
      text: |
        \usepackage{common}
        \usepackage[noblocks]{authblk}
        \renewcommand*{\Authsep}{, }
        \renewcommand*{\Authand}{, }
        \renewcommand*{\Authands}{, and }
mainfont: Latin Modern Roman
vignette: >
  %\VignetteIndexEntry{examples}
  %\VignetteEncoding{UTF-8}
  %\VignetteEngine{vws::quarto::pdf}
bibliography: references.bib
editor_options: 
  chunk_output_type: console
abstract: |
  TBD abstract goes here.
geometry:
  - left=0.5in
  - right=0.5in
  - top=0.75in
  - bottom=1.00in
  # - textwidth=4.5in
  # - marginparsep=.25in
  # - marginparwidth=2.25in
  # - showframe
execute:
  eval: false
---

```{r}
#| include: false
library(R6)
library(vws)
library(tidyverse)

set.seed(1234)
```

**TBD**

- If plotting code gets too repetitive, consider making functions for plots.

# Introduction

To implement a rejection sampler with the `vws` package, the user must make use
of an existing subclass of `Region` or implement a new one. Two such subclasses
included in the package implement the univariate "constant VWS" method described
by @VWS2024:

- `UnivariateConstRegion`: constant VWS with a continuous support.
- `IntUnivariateConstRegion`: constant VWS with an integer support.

See the manual pages for each sampler for usage and examples. These two regions
are somewhat flexible and can be adapted to a variety of problems. In this
vignette, we will describe the process of coding a customized region. We will
give one univariate example that makes use of the linear VWS method for
improved efficiency, and one multivariate example where the regions go beyond
intervals. To do this, we make use of the [R6](https://r6.r-lib.org) construct
for object-orientation in R [@Chang2021].

TBD: The package is available from <https://github.com/andrewraim/vws> and
possibly on CRAN(?).

TBD: some of the lengthier codes are not given in this document, but are
provided in external files. The paths are relative to 
<https://github.com/andrewraim/vws> (make sure this is correct).

TBD: an `R>` prompt is shown in some code displays to emphasize interaction via
the console.

TBD: For the first example, we should explain things in a lot of detail. After that,
we can give less detail, except any new aspects.

TBD: Let $\mathbb{1}_{A}(x)$ be the indicator function for the event $[x \in A]$,

TBD: We will use `ggplot2`, `dplyr` and other packages of the tidyverse [@Tidyverse2019] in the examples.

# A Brief Summary of VWS

The objective of VWS is to sample from a weighted density
<!-- -->
\begin{align*}
f(x) = f_0(x) / \psi, \quad
f_0(x) = w(x) g(x), \quad
\psi = \int_\Omega f_0(x) d\nu(x),
\end{align*}
<!-- -->
where $\Omega$ is the support, $\nu$ is a dominating measure, $g$ is assumed to be a normalized density, $w(x)$ is a nonnegative weight function, and $\psi$ is a normalizing constant. We will construct a proposal of the form
<!-- -->
\begin{align*}
h(x) = h_0(x) / \psi_*, \quad
h_0(x) = \overline{w}(x) g(x), \quad
\psi_* = \int_\Omega h_0(x) d\nu(x).
\end{align*}
<!-- -->
Suppose $\Omega$ is partitioned into regions $\mathcal{D}_1, \ldots, \mathcal{D}_N$ and there are corresponding functions $\overline{w}_j$ such that $\overline{w}_j(x) \geq w(x)$ for each $x \in \mathcal{D}_j$. We say that $\overline{w}_j$ *majorizes* $w$ on $\Omega$. Taking $\overline{w}$ as $\overline{w}(x) = \sum_{j=1}^N \overline{w}_j(x) \mathbb{1}_{\mathcal{D}_j}(x)$, the unnormalized proposal becomes
<!-- -->
\begin{align*}
h_0(x) = g(x) \sum_{j=1}^N \overline{w}_j(x) \mathbb{1}_{\mathcal{D}_j}(x)
\end{align*}
<!-- -->
With this construction, $f_0(x) \leq h_0(x)$ for all $x \in \Omega$. Therefore, classical rejection sampling can be carried out by drawing $u$ from $\text{Uniform}(0,1)$, $x$ from $h$, and accepting $x$ as a draw from $f$ if $u \leq f_0(x) / h_0(x)$. The normalized $h$ can be obtained by defining $\overline{\xi}_j = \E[\overline{w}_j(T) \mathbb{1}_{\mathcal{D}_j}(T)]$ with $T \sim g$ and $\psi_N = \sum_{j=1}^N \overline{\xi}_j$, giving the finite mixture
<!-- -->
\begin{align}
h(x)
= h_0(x) / \psi_N
= \sum_{j=1}^N \pi_j g_j(x),
\label{eqn:fmm-proposal}
\end{align}
<!-- -->
Equation \eqref{eqn:fmm-proposal} is seen to be a finite mixture with mixing weights $\pi_j = \overline{\xi}_j / \{ \sum_{\ell=1}^N \overline{\xi}_\ell \}$, and component densities
<!-- -->
$$
g_j(x) = 
\overline{w}_j(x) g(x) \mathbb{1}_{\mathcal{D}_j}(x) / \overline{\xi}_j
$$
<!-- -->
which are truncated and reweighted versions of base distribution $g$. In addition to the majorizer, suppose that $\underline{w}_j$ is a minorizer of $w$ so that
$0 \leq \underline{w}_j(x) \leq w(x)$ for all $x \in \mathcal{D}_j$,
and let $\underline{\xi}_j = \E[\underline{w}_j(T) \ind(T \in \mathcal{D}_j)]$ with $T \sim g$. When $h$ is used as a proposal in rejection sampling, an upper bound for the probability of rejection is
<!-- -->
\begin{align}
1 - \frac{\sum_{j=1}^N \underline{\xi}_j}{\sum_{j=1}^N \overline{\xi}_j}.
\label{eqn:bound}
\end{align}
<!-- -->
This bound can be used to quickly determine whether the proposal will be viable for rejection sampling. If the bound is seen to be large, the proposal may be refined by altering the partition or considering a different majorizer.

TBD: mention the constant and linear majorizers. Perhaps we want these subsections in the code design section near their implementation details?

# Package Design

::: {.callout-note title="TBD"}
- We use R6 in some places to promote more formal object-orientation.
- The `FMMProposal` class encapsulates the finite mixture proposal.
- A `Region` contains all of the problem-specific logic.
- `UnivariateConstRegion` implements constant VWS for univariate regions that
  are partitioned into intervals. It has a built in optimization (may want to
  make this more configurable!)
- `IntUnivariateConstRegion` is a special version for integer supports. E.g.,
  it avoids bifurcating into regions that contain no integers.
- `univariate_helper` for `UnivariateConstRegion` and `IntUnivariateConstRegion`.
- The `adapt_midpoint` function partitions the proposal to make it better
  approximate the target.
- The `rejection` function does rejection sampling with a proposal.
- Maybe explain all of the pieces first, then show how to use them in more
  detail.
- Remark: many of the calculations are done on the log-scale. Describe the
  log-sum-exp functions.
- Remark: Gumbel trick to draw from the proposal. (Does this preclude doing a
  binary search though?)
- Remark: We don't use Rcpp at the moment because interoperability between C++
  classes and R becomes more complicated. It is possible with Rcpp Modules
  though.
- Identify the main functions in the interface.

Outline of this section

1. High level description of the design
	a. `FMMProposal`
	b. `rejection`
	c. Other stuff at a high level
2. Constant VWS with Univariate Regions
	a. `UnivariateConstRegion`
	b. `univariate_helper`
	c. `IntUnivariateConstRegion`
	d. `optimize` and how to override
3. User-Defined Problems
	a. `Region` abstract class and how to override.
	   Maybe easier to show by example later.
4. Adapt
	a. `adapt_midpoint`

Maybe we should get rid of friendly constructors... they don't do much

Can we remove `log_target_pdf_unnorm` and just use `d` with the right combination of arguments?

How about the name `d_g` instead of `d_base`?
:::

The `vws` package aims to support the methodology which was described in the previous section. The present section will describe tools in the package which can be used to formulate a problem, construct a proposal, and generate samples. Use of the package focuses on two `R6` classes. The `FMMProposal` class represents finite mixture \eqref{eqn:fmm-proposal} and encapsulates operations needed for rejection sampling. The `Region` class represents region $\mathcal{D}_j$ and the operations that must be supported on it for VWS; essentially, all problem-specific logic is coded within a `Region`. An `FMMProposal` object is created from a list of one or more `Region` objects that represent the partition $\mathcal{D}_1, \ldots, \mathcal{D}_N$ of $\Omega$. Details of all included `R6` classes are provided in manual pages such as `?FMMProposal` and `?Region`.

<!--
![An overview of the `vws` package design.](diagram.pdf){#fig-diagram}
-->

\begin{figure}
\centering
\includegraphics[trim={0 5.5in 4in 0},clip, width=0.8\textwidth]{diagram.pdf}
\caption{An overview of the `vws` package design.}
\label{fig:diagram}
\end{figure}

`FMMProposal` has the following public methods.

```{r}
#| prompt: true
names(FMMProposal$public_methods)
```

```{r}
#| include: false
# If the interface has changed, catch it and bail out
actual = names(FMMProposal$public_methods)
expected = c("initialize", "get_xi_upper", "get_xi_lower", "get_bifurcatable",
	"get_regions", "rejection_bound", "nc", "r", "d", "log_target_pdf_unnorm",
	"summary", "print", "clone")
setequal(actual, expected) |> stopifnot()
```

The methods `r`, `d`, and `nc` represent operations of the finite mixture distribution: `r` generates draws, `d` evaluates the density, and `nc` evaluates normalizing constant $\psi_N$. Method `rejection_bound` returns either the bound \eqref{eqn:bound} or a vector \eqref{eqn:bound-components} which represents the contribution to \eqref{eqn:bound} of each region.

The remaining methods will typically not be directly needed by users. 

- `initialize` is a standard `R6` constructor that allows objects to be created
  via `FMMProposal$new(...)`.
- Methods `summary` and `print` provide a meaningful display for objects of
  the class when printed.
- Method `log_target_pdf_unnorm` computes the unnormalized log-density
  $\log h_0(x) = \log \overline{w}(x) + \log g(x)$ for $x \in \Omega$ which is
  used as an envelope in rejection sampling.
- Accessors for private data members:
	a. `get_xi_upper` returns $\overline{\xi}_1, \ldots, \overline{\xi}_N$; 				a. `get_xi_lower` returns $\underline{\xi}_1, \ldots, \underline{\xi}_N$;
	a. `get_bifurcatable` returns a vector of logical values indicating whether 
	   respective regions can be bifurcated (described further in Section TBD);
	   and
	a. `get_regions` returns the list of `Region` objects on which the
	   `FMMProposal` was constructed.

`Region` is an abstract base class whose interface represents all problem-specific logic that must be coded to implement VWS. The interface consists of the following methods.

```{r}
#| prompt: true
names(Region$public_methods)
```

```{r}
#| include: false
# If the interface has changed, catch it and bail out
actual = names(Region$public_methods)
expected = c("d_base", "w", "r", "d", "s", "w_major", "bifurcate", "is_bifurcatable",
	"xi_upper", "xi_lower", "description", "print", "clone")
setequal(actual, expected) |> stopifnot()
```

The methods are briefly described as follows. Expressions with an index $j$ correspond to a $\mathcal{D}_j$ which is associated with the `Region` object.

- `w` is the original weight function $w(x)$ and `w_maj` is the majorized
  weight function $\overline{w}_j(x)$ .
- `d_base` represents the density function $g$.
- `r`, `d`, and `s` are distribution functions for the truncated and reweighted
  distribution $g_j$. `r` generates draws, `d` computes the density, and `s` is
  an indicator of whether a given point is in the support.
- `xi_upper` and `xi_lower` compute $\overline{\xi}_j$ and $\underline{\xi}_j$,
  respectively.
- `bifurcate` and `is_bifurcatable` are used in adaptation which discussed in
  Section TBD. `is_bifurcatable` is an indicator of whether the region can be
  bifurcated into two new `Region` objects; i.e., the indicator is `FALSE` if 
  $\mathcal{D}_j$ contains no support points. The function `bifurcate` carries
  out the bifurcation and returns two new `Region` objects.
- `description` and `print` create a meaningful display when printing an object.

The `rejection` function takes an object `h` of class `FMMProposal` and carries out
the rejection sampling algorithm to obtain `n` draws. The return value of `rejection` is a list where each element represents an accepted draw. Optional arguments may be passed
through a `rejection_control` (S3) object, including: a count of rejections that can be tolerated before halting, and whether to return additional information on rejections which occurred during sampling. The following display gives a typical workflow for sampling.

```{R}
#| eval: false
h = FMMProposal$new(regions)
ctrl = rejection_control(max_rejects = 1000)
rejection(h, n = 1000)
```

```{r}
#| include: false
# If the interface has changed, catch it and bail out
actual = names(formals(rejection_control))
expected = c("max_rejects", "report", "extra_outputs", "action_incomplete")
base::setequal(actual, expected) |> stopifnot()
```

## Constant VWS with Univariate Regions

When $w_j(x)$ is finite on $\mathcal{D}_j$, the constant $\overline{w}_j = \sup_{x \in \mathcal{D}_j} w(x)$ can serve as the majorizer $\overline{w}_j$. The minorizer may also be taken as the constant $\underline{w}_j = \inf_{x \in \mathcal{D}_j} w(x)$. Here we obtain component densities
$g_j(x) = g(x) \ind(x \in \mathcal{D}_j) / \Prob(T \in \mathcal{D}_j)$
along with the quantities
$\overline{\xi}_j = \overline{w}_j \Prob(T \in \mathcal{D}_j)$ and
$\underline{\xi}_j = \underline{w}_j \Prob(T \in \mathcal{D}_j)$.
Operations in the univariate case can be automated, making this choice of VWS sampler
relatively easy to implement. More details will be given in Section TBD.

## User-Defined Problems

## Adapting the Proposal

A natural choice to partition a univariate $\Omega = (a,b]$ is by breaking it into intervals defined by knots $\alpha_0 < \cdots < \alpha_N$. Suppose $\alpha_0 \equiv a$, $\alpha_N \equiv b$, and $\alpha_1, \ldots, \alpha_{N-1}$ are free to choose. The following rule of thumb which seeks to reduce \eqref{eqn:bound}. Let
<!-- -->
\begin{align}
\rho_\ell = \{
\overline{\xi}_\ell - \underline{\xi}_\ell
\} \Big/ \{
\sum_{j=1}^N \overline{\xi}_j
\},
\label{eqn:bound-components}
\end{align}
<!-- -->
be the contribution of region $\ell$ to \eqref{eqn:bound}. Draw index $\ell^*$ from $(1, \ldots, N)$ with probabilities proportional to $\rho_1, \ldots, \rho_N$, then bifurcate region $\ell^*$ into regions $\mathcal{D}_\ell^{(1)} = (\alpha_{\ell-1}, \alpha_{\ell^*}]$ and $\mathcal{D}_\ell^{(2)} = (\alpha_{\ell^*}, \alpha_\ell]$. When the support is continuous, the specific bifurcation point is taken to be
<!-- -->
\begin{align*}
\alpha_{\ell^*} =
\begin{cases}
0 & \text{if $\alpha_{\ell-1} = -\infty$ and $\alpha_\ell = \infty$}, \\
\alpha_\ell - |\alpha_\ell| - 1 & \text{if $\alpha_{\ell-1} = -\infty$ and $\alpha_\ell < \infty$}, \\
\alpha_{\ell-1} + |\alpha_{\ell-1}| + 1 & \text{if $\alpha_{\ell-1} > -\infty$ and $\alpha_\ell = \infty$}, \\
(\alpha_{\ell-1} + \alpha_\ell) / 2 & \text{otherwise}.
\end{cases}
\end{align*}
<!-- -->
When the support is integer-valued, we instead consider
<!-- -->
\begin{align*}
\alpha_{\ell^*} =
\begin{cases}
0 & \text{if $\alpha_{\ell-1} = -\infty$ and $\alpha_\ell = \infty$}, \\
\alpha_\ell - |\alpha_\ell| - 1 & \text{if $\alpha_{\ell-1} = -\infty$ and $\alpha_\ell < \infty$}, \\
\alpha_{\ell-1} + |\alpha_{\ell-1}| + 1 & \text{if $\alpha_{\ell-1} > -\infty$ and $\alpha_\ell = \infty$}, \\
\lceil (\alpha_{\ell-1} + \alpha_\ell) / 2 \rceil & \text{otherwise}.
\end{cases}
\end{align*}
<!-- -->
Furthermore, regions containing no integers are excluded from further bifrucation.

# Examples

## Lognormal-Normal Convolution

TBD: this problem came up in @DirectSamplingDAS2021 and @DPSimulation2022.

## Bessel Count Distribution

TBD: this sampling problem comes up in @Devroye2002.

```{r}
#| prompt: true
source("../inst/examples/bessel/functions.R")
```

In this example, we consider generating from the Bessel density described by
@Devroye2002 as

$$
f(x) = \frac{(a/2)^{2x+\nu}}{I_v(a) \cdot x! \cdot \Gamma(x + \nu + 1)}
\cdot \mathbb{1}_{\mathbb{N}}(x), \quad
\nu > -1, \quad
a > 0,
$$

where we denote the positive integers as $\mathbb{N} = \{ 0, 1, 2, \ldots \}$
and

$$
I_v(a) = \sum_{x=0}^\infty \frac{(a/2)^{2x+\nu}}{x! \cdot \Gamma(x + \nu + 1)}
$$

is a modified Bessel function of the first kind.

At the time the paper was written, @Devroye2002 considered it difficult to
generate exact draws from this distribution. He develops what appears to be a
customized accept-reject method after establishing properties of the
distribution. We can draw from this distribution fairly easily without such an
in-depth analysis.

Our approach is to decompose the density into

\begin{align*}
f(x)
&= \frac{(a/2)^{2x+\nu}}{I_v(a) \cdot x! \cdot \Gamma(x + \nu + 1)}
\cdot \mathbb{1}_{\mathbb{N}}(x) \\
%
&\propto 
\frac{e^{a^2/4} (a/2)^\nu}{\Gamma(x + \nu + 1)}
\frac{(a/2)^{2x} e^{-a^2/4}}{x!} \mathbb{1}_{\mathbb{N}}(x) \\
%
&\propto w(x) g(x),
\end{align*}

where $g(x) = \frac{(a^2/4)^x e^{-a^2/4}}{x!} \mathbb{1}_{\mathbb{N}}(x)$
represents a $\text{Poisson}(a^2/4)$ base distribution and weight function
specified on the log scale as by $\log w(x) = -\log \Gamma(x + \nu + 1)$.
Notice that we can disregard many of the normalizing constants with this
sampler.

We can explicitly describe computations involved in the sampler.

- Make regions of the form $\mathcal{D}_j = (\alpha_{j-1}, \alpha_j]$.
- Compute $P(T \in \mathcal{D}_j)$.
- Optimize $w(x)$ on $\mathcal{D}_j$ to obtain $\overline{w}_j$ and
	  $\underline{w}_j$.
- Draw from Poisson truncated to $\mathcal{D}_j$.
- Adaptation algorithm that uses integer midpoint.

We can also show some displays of how the sampler performs.

- Volume and/or log volume as we increase $N$ with adaptation.
- The exact density versus the proposal density for several values of $N$ along
  the adaptation path.
- The number of draws rejected in practice along the adaptation path (say, if
  we request a large number such as $n = 10^7$).

It looks like we can capture the distribution almost exactly by covering the
entire support with a not-too-large choice of $N$, but this will depend on the
parameters $a$ and $\nu$. When we have adapted to this point, it becomes
extremely rare to reject any candidates.

Consider giving background information about the Bessel distribution to show
why it was of special interest to Devroye.

```{r}
nu = -0.5
lambda = 10

helper = poisson_univariate_helper(lambda^2 / 4)

w = function(x, log = TRUE) {
	out = -lgamma(x + nu + 1) + lambda^2 / 4 + nu * log(lambda / 2)
	if (log) { return(out) } else { return(exp(out)) }
}

support = int_univariate_const_region(a = -1, b = Inf, w = w, g = helper)
regions = list(support)

h_init = fmm_proposal(regions)
ctrl = rejection_control(report = 10)
adapt_out = adapt_midpoint(h_init, N = 30, control = ctrl)
h = adapt_out$h

data.frame(logbdd = adapt_out$log_bdd_hist) %>%
	mutate(step = row_number() - 1) %>%
	ggplot() +
	geom_line(aes(x = step, y = logbdd)) +
	scale_y_continuous(n.breaks = 10) +
	xlab("Step") +
	ylab("Log of Bound") +
	theme_minimal()

ctrl = rejection_control(max_rejects = 10000, report = 2000)
out = rejection(h, n = 10000, control = ctrl)
x = unlist(out)
```

Plot the empirical distribution of the draws with the target density.

```{r}
# Compute empirical density of draws and density values
n = length(x)
tab_out = factor(x, levels = seq(0, 11)) |> table()
x_vals = tab_out |> names() |> as.integer()
d_vals_emp = (tab_out / n) |> as.numeric()
d_vals = d_bessel(x_vals, a = lambda, nu = nu)

data.frame(x = x_vals, d_emp = d_vals_emp, d = d_vals) %>%
	ggplot() +
	geom_point(aes(x = x, y = d), pch = 1) +
	geom_point(aes(x = x, y = d_emp), pch = 3) +
	ylab("Probability") +
	theme_minimal()
```

Plot proposal versus the target on the log-scale.

```{r}
log_h = function(x) { h$d(as.list(x), log = TRUE) }
log_f = function(x) { d_bessel(x, a = lambda, nu = nu, log = TRUE) }

df = data.frame(x = x_vals) %>%
	mutate(log_h_vals = log_h(x)) %>%
	mutate(log_f_vals = log_f(x))

ggplot(df) +
	geom_point(aes(x, log_h_vals), pch = 1) +
	geom_point(aes(x, log_f_vals), pch = 3) +
	theme_minimal()
```

## Von Mises Fisher

TBD: needs some explanation. We use both constant and linear majorizers here.
For both versions of the sampler, we consider the same decomposition.

Suppose $X$ has density

\begin{align}
f(x) =
\frac{
(\kappa / 2)^{d/2 - 1} (1 - x^2)^{(d-3)/2} \exp(\kappa x)
}{
\sqrt{\pi} \cdot I_{d/2 - 1}(\kappa) \cdot \Gamma((d-1)/2)
} \cdot \mathbb{1}_{(-1,1)}(x).
\label{eqn:vmf-target}
\end{align}

Let us decompose $f$ into

\begin{align*}
f(x) \propto
\underbrace{(1 - x^2)^{(d-3)/2}}_{w(x)}
\underbrace{\exp(\kappa x) \cdot \mathbb{1}_{(-1,1)}(x)}_{g_0(x)},
\end{align*}

where $w$ is a nonnegative weight function and $g_0$ is proportional to density

\begin{align*}
g(x) = \frac{\kappa e^{\kappa x}}{e^\kappa - e^{-\kappa}} \cdot \mathbb{1}_{(-1,1)}(x).
\end{align*}

The CDF corresponding to $g$ is

\begin{align*}
G(x) = \frac{e^{\kappa x} - e^{-\kappa x}}{e^\kappa - e^{-\kappa}} \cdot,
\quad x \in (-1, 1)
\end{align*}

and the quantile function is

\begin{align*}
G^{-1}(\varphi) = \frac{1}{\kappa} \log\left[e^{\kappa a} + \varphi (e^{\kappa b} - e^{\kappa a}) \right], \quad \varphi \in [0,1].
\end{align*}


Check the manual entry for `Region` to see which methods need to be implemented.

```{r}
#| eval: false
#| prompt: true
?Region
```

The needed operations for the base and target distributions are defined in the
following files.

```{r}
#| prompt: true
source("../inst/examples/vmf/base.R")
source("../inst/examples/vmf/vmf-base-helper.R")
source("../inst/examples/vmf/target.R")
source("../inst/examples/vmf/VMFLinearRegion.R")
```

TBD: we have to truncate support to something within $[-1,1]$ when $d < 3$
because $w$ is not finite at the endpoints.

### Constant VWS

Define base distribution and weight function.

```{r}
d = 2
kappa = 0.2

helper = vmf_base_helper(kappa)

w = function(x, log = FALSE) {
	out = (d - 3) / 2 * log(1 - x^2)
	if (log) { return(out) } else { return(exp(out)) }
}
```

```{r}
support = univariate_const_region(a = 1e-4 - 1, b = 1 - 1e-4, w = w, g = helper)
regions = list(support)
```

Adapt the proposal.

```{r}
h_init = fmm_proposal(regions)
ctrl = rejection_control(report = 20)
adapt_out = adapt_midpoint(h_init, N = 100, control = ctrl)
h = adapt_out$h
```

Plot the rate of adaptation improvement. (TBD: consider making this an object
that can quickly be plotted. But this might add a dependency if it's ggplot).

```{r}
data.frame(bdd = exp(adapt_out$log_bdd_hist)) %>%
	mutate(step = row_number() - 1) %>%
	ggplot() +
	geom_line(aes(x = step, y = bdd)) +
	scale_y_continuous(n.breaks = 10) +
	xlab("Step") +
	ylab("Bound") +
	theme_minimal()
```

Generate draws.

```{r}
ctrl = rejection_control(max_rejects = 10000, report = 1000)
out = rejection(h, n = 10000, control = ctrl)
x = unlist(out)
```

Plot the empirical distribution of the draws with the target density.

```{r}
data.frame(x = x) %>%
	ggplot() +
	geom_histogram(aes(x = x, y = after_stat(density)), col = "black",
		fill = NA, bins = 25) +
	geom_function(fun = d_target, args = list(kappa = kappa, d = d),
		lty = 2, xlim = c(1e-2 - 1, 1 - 1e-2)) +
	ylab("Density") +
	theme_minimal()
```

### Linear VWS

For this region:

- $w$ is assumed to be $w(x) = (1 - x^2)^{(d - 3)/2}$
- $g$ is assumed to be proportional to $\exp(\kappa x)$
- majorized $w$ is assumed to be of the form $\exp(\beta_0 + \beta_1 x)$

Note that $\log(w(-1)) = \log(w(1)) = \infty$ with this choice when $d < 3$. A
workaround is to exclude the endpoints from the support.

```{r}
d = 2
kappa = 0.2
```

Create a single region of class `VMFLinearRegion`.

```{r}
support = VMFLinearRegion$new(a = 1e-4 - 1, b = 1 - 1e-4, kappa = kappa, d = d)
regions = list(support)
```

Adapt the proposal.

```{r}
h_init = fmm_proposal(regions)
ctrl = rejection_control(report = 20)
adapt_out = adapt_midpoint(h_init, N = 100, control = ctrl)
h = adapt_out$h
```

Plot the rate of adaptation improvement. Plot on both the original scale and
log-scale; the log-scale helps to see improvement in later steps.

```{r}
#| out-width: "48%"
#| fig-show: hold
#| fig-cap:
#|   - "Original scale."
#|   - "Log scale."

# TBD: why doesn't the following chunk option work to get two columns?
# layout-ncol: 2
# fig-column: body

data.frame(bdd = exp(adapt_out$log_bdd_hist)) %>%
	mutate(step = row_number() - 1) %>%
	ggplot() +
	geom_line(aes(x = step, y = bdd)) +
	scale_y_continuous(n.breaks = 10) +
	xlab("Step") +
	ylab("Bound") +
	theme_minimal()
data.frame(logbdd = adapt_out$log_bdd_hist) %>%
	mutate(step = row_number() - 1) %>%
	ggplot() +
	geom_line(aes(x = step, y = logbdd)) +
	scale_y_continuous(n.breaks = 10) +
	xlab("Step") +
	ylab("Log of Bound") +
	theme_minimal()
```

Generate draws.
```{r}
control = rejection_control(max_rejects = 100, report = 2000)
out = rejection(h, n = 10000, control = control)
x = unlist(out)
```

Plot the empirical distribution of the draws with the target density.

```{r}
data.frame(x = x) %>%
	ggplot() +
	geom_histogram(aes(x = x, y = after_stat(density)), col = "black",
		fill = NA, bins = 25) +
	geom_function(fun = d_target, args = list(kappa = kappa, d = d),
		lty = 2, xlim = c(1e-2 - 1, 1 - 1e-2)) +
	ylab("Density") +
	theme_minimal()
```

Plot proposal versus the target on the log-scale.

```{r}
log_h = function(x) { h$d(as.list(x), log = TRUE) }
log_f = function(x) { d_target(x, kappa = kappa, d = d, log = TRUE) }

ggplot() +
	geom_function(fun = log_f) +
	geom_function(fun = log_h, lty = 2) +
	scale_x_continuous(limits = c(1e-2 - 1, 1 - 1e-2)) +
	theme_minimal()
```

# Conclusions

# Acknowledgments {-}

TBD

# References
