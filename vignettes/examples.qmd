---
title: "Vertical Weighted Strips in R"
author:
  - name: Andrew M. Raim^[Corresponding author <andrew.raim@gmail.com>.
      Center for Statistical Research & Methodology,
      U.S. Census Bureau,
      Washington, DC, 20233, U.S.A.
      **Disclaimer**`:` This document is released to inform interested parties
      of ongoing research and to encourage discussion of work in progress. Any
      views expressed are those of the authors and not those of the U.S. Census
      Bureau.]
    email: andrew.raim@gmail.com
  - name: James A. Livsey
  - name: Kyle M. Irimata
affiliations:
  - name: U.S. Census Bureau
    department: Center for Statistical Research and Methodology
    address: 4600 Silver Hill Road
    city: Washington DC
    country: U.S.A.
format:
  pdf:
    toc: true
    number-sections: true
    colorlinks: true
    link-citations: true
#    margin-left: 0.50 in
#    margin-right: 0.50 in
#    margin-top: 0.75 in
#    margin-bottom: 1.00 in
    prompt: false
    template-partials: 
      - title.tex
    include-in-header:
      text: |
        \usepackage[noblocks]{authblk}
        \renewcommand*{\Authsep}{, }
        \renewcommand*{\Authand}{, }
        \renewcommand*{\Authands}{, and }
mainfont: Latin Modern Roman
vignette: >
  %\VignetteIndexEntry{examples}
  %\VignetteEncoding{UTF-8}
  %\VignetteEngine{vws::quarto::pdf}
bibliography: references.bib
editor_options: 
  chunk_output_type: console
abstract: |
  TBD abstract goes here.
geometry:
  - left=0.5in
  - right=0.5in
  - top=0.75in
  - bottom=1.00in
  # - textwidth=4.5in
  # - marginparsep=.25in
  # - marginparwidth=2.25in
  # - showframe
---

```{r}
#| include: false
library(R6)
library(vws)
library(tidyverse)

set.seed(1234)
```

**TBD**

- If plotting code gets too repetitive, consider making functions for plots.

# Introduction

To implement a rejection sampler with the `vws` package, the user must make use
of an existing subclass of `Region` or implement a new one. Two such subclasses
included in the package implement the univariate "constant VWS" method described
by @VWS2024:

- `UnivariateConstRegion`: constant VWS with a continuous support.
- `IntUnivariateConstRegion`: constant VWS with an integer support.

See the manual pages for each sampler for usage and examples. These two regions
are somewhat flexible and can be adapted to a variety of problems. In this
vignette, we will describe the process of coding a customized region. We will
give one univariate example that makes use of the linear VWS method for
improved efficiency, and one multivariate example where the regions go beyond
intervals. To do this, we make use of the [R6](https://r6.r-lib.org) construct
for object-orientation in R [@Chang2021].

TBD: The package is available from <https://github.com/andrewraim/vws> and
possibly on CRAN(?).

TBD: some of the lengthier codes are not given in this document, but are
provided in external files. The paths are relative to 
<https://github.com/andrewraim/vws> (make sure this is correct).

TBD: an `R>` prompt is shown in some code displays to emphasize interaction via
the console.

TBD: For the first example, we should explain things in a lot of detail. After that,
we can give less detail, except any new aspects.

TBD: Let $\mathbb{1}_{A}(x)$ be the indicator function for the event $[x \in A]$,

TBD: We will use `ggplot2`, `dplyr` and other packages of the tidyverse [@Tidyverse2019] in the examples.

# Review of VWS

# Package Design

# Examples

## Lognormal-Normal Convolution

TBD: this problem came up in @DirectSamplingDAS2021 and @DPSimulation2022.

## Bessel Count Distribution

TBD: this sampling problem comes up in @Devroye2002.

```{r}
#| prompt: true
source("../inst/examples/bessel/functions.R")
```

In this example, we consider generating from the Bessel density described by
@Devroye2002 as

$$
f(x) = \frac{(a/2)^{2x+\nu}}{I_v(a) \cdot x! \cdot \Gamma(x + \nu + 1)}
\cdot \mathbb{1}_{\mathbb{N}}(x), \quad
\nu > -1, \quad
a > 0,
$$

where we denote the positive integers as $\mathbb{N} = \{ 0, 1, 2, \ldots \}$
and

$$
I_v(a) = \sum_{x=0}^\infty \frac{(a/2)^{2x+\nu}}{x! \cdot \Gamma(x + \nu + 1)}
$$

is a modified Bessel function of the first kind.

At the time the paper was written, @Devroye2002 considered it difficult to
generate exact draws from this distribution. He develops what appears to be a
customized accept-reject method after establishing properties of the
distribution. We can draw from this distribution fairly easily without such an
in-depth analysis.

Our approach is to decompose the density into

\begin{align*}
f(x)
&= \frac{(a/2)^{2x+\nu}}{I_v(a) \cdot x! \cdot \Gamma(x + \nu + 1)}
\cdot \mathbb{1}_{\mathbb{N}}(x) \\
%
&\propto 
\frac{e^{a^2/4} (a/2)^\nu}{\Gamma(x + \nu + 1)}
\frac{(a/2)^{2x} e^{-a^2/4}}{x!} \mathbb{1}_{\mathbb{N}}(x) \\
%
&\propto w(x) g(x),
\end{align*}

where $g(x) = \frac{(a^2/4)^x e^{-a^2/4}}{x!} \mathbb{1}_{\mathbb{N}}(x)$
represents a $\text{Poisson}(a^2/4)$ base distribution and weight function
specified on the log scale as by $\log w(x) = -\log \Gamma(x + \nu + 1)$.
Notice that we can disregard many of the normalizing constants with this
sampler.

We can explicitly describe computations involved in the sampler.

- Make regions of the form $\mathcal{D}_j = (\alpha_{j-1}, \alpha_j]$.
- Compute $P(T \in \mathcal{D}_j)$.
- Optimize $w(x)$ on $\mathcal{D}_j$ to obtain $\overline{w}_j$ and
	  $\underline{w}_j$.
- Draw from Poisson truncated to $\mathcal{D}_j$.
- Adaptation algorithm that uses integer midpoint.

We can also show some displays of how the sampler performs.

- Volume and/or log volume as we increase $N$ with adaptation.
- The exact density versus the proposal density for several values of $N$ along
  the adaptation path.
- The number of draws rejected in practice along the adaptation path (say, if
  we request a large number such as $n = 10^7$).

It looks like we can capture the distribution almost exactly by covering the
entire support with a not-too-large choice of $N$, but this will depend on the
parameters $a$ and $\nu$. When we have adapted to this point, it becomes
extremely rare to reject any candidates.

Consider giving background information about the Bessel distribution to show
why it was of special interest to Devroye.

```{r}
nu = -0.5
lambda = 10

helper = poisson_univariate_helper(lambda^2 / 4)

w = function(x, log = TRUE) {
	out = -lgamma(x + nu + 1) + lambda^2 / 4 + nu * log(lambda / 2)
	if (log) { return(out) } else { return(exp(out)) }
}

support = int_univariate_const_region(a = -1, b = Inf, w = w, g = helper)
regions = list(support)

h_init = fmm_proposal(regions)
ctrl = rejection_control(report = 10)
adapt_out = adapt_midpoint(h_init, N = 30, control = ctrl)
h = adapt_out$h

data.frame(logbdd = adapt_out$log_bdd_hist) %>%
	mutate(step = row_number() - 1) %>%
	ggplot() +
	geom_line(aes(x = step, y = logbdd)) +
	scale_y_continuous(n.breaks = 10) +
	xlab("Step") +
	ylab("Log of Bound") +
	theme_minimal()

ctrl = rejection_control(max_rejects = 10000, report = 2000)
out = rejection(h, n = 10000, control = ctrl)
x = unlist(out)
```

Plot the empirical distribution of the draws with the target density.

```{r}
# Compute empirical density of draws and density values
n = length(x)
tab_out = factor(x, levels = seq(0, 11)) |> table()
x_vals = tab_out |> names() |> as.integer()
d_vals_emp = (tab_out / n) |> as.numeric()
d_vals = d_bessel(x_vals, a = lambda, nu = nu)

data.frame(x = x_vals, d_emp = d_vals_emp, d = d_vals) %>%
	ggplot() +
	geom_point(aes(x = x, y = d), pch = 1) +
	geom_point(aes(x = x, y = d_emp), pch = 3) +
	ylab("Probability") +
	theme_minimal()
```

Plot proposal versus the target on the log-scale.

```{r}
log_h = function(x) { h$d(as.list(x), log = TRUE) }
log_f = function(x) { d_bessel(x, a = lambda, nu = nu, log = TRUE) }

df = data.frame(x = x_vals) %>%
	mutate(log_h_vals = log_h(x)) %>%
	mutate(log_f_vals = log_f(x))

ggplot(df) +
	geom_point(aes(x, log_h_vals), pch = 1) +
	geom_point(aes(x, log_f_vals), pch = 3) +
	theme_minimal()
```

## Von Mises Fisher

TBD: needs some explanation. We use both constant and linear majorizers here.
For both versions of the sampler, we consider the same decomposition.

Suppose $X$ has density

\begin{align}
f(x) =
\frac{
(\kappa / 2)^{d/2 - 1} (1 - x^2)^{(d-3)/2} \exp(\kappa x)
}{
\sqrt{\pi} \cdot I_{d/2 - 1}(\kappa) \cdot \Gamma((d-1)/2)
} \cdot \mathbb{1}_{(-1,1)}(x).
\label{eqn:vmf-target}
\end{align}

Let us decompose $f$ into

\begin{align*}
f(x) \propto
\underbrace{(1 - x^2)^{(d-3)/2}}_{w(x)}
\underbrace{\exp(\kappa x) \cdot \mathbb{1}_{(-1,1)}(x)}_{g_0(x)},
\end{align*}

where $w$ is a nonnegative weight function and $g_0$ is proportional to density

\begin{align*}
g(x) = \frac{\kappa e^{\kappa x}}{e^\kappa - e^{-\kappa}} \cdot \mathbb{1}_{(-1,1)}(x).
\end{align*}

The CDF corresponding to $g$ is

\begin{align*}
G(x) = \frac{e^{\kappa x} - e^{-\kappa x}}{e^\kappa - e^{-\kappa}} \cdot,
\quad x \in (-1, 1)
\end{align*}

and the quantile function is

\begin{align*}
G^{-1}(\varphi) = \frac{1}{\kappa} \log\left[e^{\kappa a} + \varphi (e^{\kappa b} - e^{\kappa a}) \right], \quad \varphi \in [0,1].
\end{align*}


Check the manual entry for `Region` to see which methods need to be implemented.

```{r}
#| eval: false
#| prompt: true
?Region
```

The needed operations for the base and target distributions are defined in the
following files.

```{r}
#| prompt: true
source("../inst/examples/vmf/base.R")
source("../inst/examples/vmf/vmf-base-helper.R")
source("../inst/examples/vmf/target.R")
source("../inst/examples/vmf/VMFLinearRegion.R")
```

TBD: we have to truncate support to something within $[-1,1]$ when $d < 3$
because $w$ is not finite at the endpoints.

### Constant VWS

Define base distribution and weight function.

```{r}
d = 2
kappa = 0.2

helper = vmf_base_helper(kappa)

w = function(x, log = FALSE) {
	out = (d - 3) / 2 * log(1 - x^2)
	if (log) { return(out) } else { return(exp(out)) }
}
```

```{r}
support = univariate_const_region(a = 1e-4 - 1, b = 1 - 1e-4, w = w, g = helper)
regions = list(support)
```

Adapt the proposal.

```{r}
h_init = fmm_proposal(regions)
ctrl = rejection_control(report = 20)
adapt_out = adapt_midpoint(h_init, N = 100, control = ctrl)
h = adapt_out$h
```

Plot the rate of adaptation improvement. (TBD: consider making this an object
that can quickly be plotted. But this might add a dependency if it's ggplot).

```{r}
data.frame(bdd = exp(adapt_out$log_bdd_hist)) %>%
	mutate(step = row_number() - 1) %>%
	ggplot() +
	geom_line(aes(x = step, y = bdd)) +
	scale_y_continuous(n.breaks = 10) +
	xlab("Step") +
	ylab("Bound") +
	theme_minimal()
```

Generate draws.

```{r}
ctrl = rejection_control(max_rejects = 10000, report = 1000)
out = rejection(h, n = 10000, control = ctrl)
x = unlist(out)
```

Plot the empirical distribution of the draws with the target density.

```{r}
data.frame(x = x) %>%
	ggplot() +
	geom_histogram(aes(x = x, y = after_stat(density)), col = "black",
		fill = NA, bins = 25) +
	geom_function(fun = d_target, args = list(kappa = kappa, d = d),
		lty = 2, xlim = c(1e-2 - 1, 1 - 1e-2)) +
	ylab("Density") +
	theme_minimal()
```

### Linear VWS

For this region:

- $w$ is assumed to be $w(x) = (1 - x^2)^{(d - 3)/2}$
- $g$ is assumed to be proportional to $\exp(\kappa x)$
- majorized $w$ is assumed to be of the form $\exp(\beta_0 + \beta_1 x)$

Note that $\log(w(-1)) = \log(w(1)) = \infty$ with this choice when $d < 3$. A
workaround is to exclude the endpoints from the support.

```{r}
d = 2
kappa = 0.2
```

Create a single region of class `VMFLinearRegion`.

```{r}
support = VMFLinearRegion$new(a = 1e-4 - 1, b = 1 - 1e-4, kappa = kappa, d = d)
regions = list(support)
```

Adapt the proposal.

```{r}
h_init = fmm_proposal(regions)
ctrl = rejection_control(report = 20)
adapt_out = adapt_midpoint(h_init, N = 100, control = ctrl)
h = adapt_out$h
```

Plot the rate of adaptation improvement. Plot on both the original scale and
log-scale; the log-scale helps to see improvement in later steps.

```{r}
#| out-width: "48%"
#| fig-show: hold
#| fig-cap:
#|   - "Original scale."
#|   - "Log scale."

# TBD: why doesn't the following chunk option work to get two columns?
# layout-ncol: 2
# fig-column: body

data.frame(bdd = exp(adapt_out$log_bdd_hist)) %>%
	mutate(step = row_number() - 1) %>%
	ggplot() +
	geom_line(aes(x = step, y = bdd)) +
	scale_y_continuous(n.breaks = 10) +
	xlab("Step") +
	ylab("Bound") +
	theme_minimal()
data.frame(logbdd = adapt_out$log_bdd_hist) %>%
	mutate(step = row_number() - 1) %>%
	ggplot() +
	geom_line(aes(x = step, y = logbdd)) +
	scale_y_continuous(n.breaks = 10) +
	xlab("Step") +
	ylab("Log of Bound") +
	theme_minimal()
```

Generate draws.
```{r}
control = rejection_control(max_rejects = 100, report = 2000)
out = rejection(h, n = 10000, control = control)
x = unlist(out)
```

Plot the empirical distribution of the draws with the target density.

```{r}
data.frame(x = x) %>%
	ggplot() +
	geom_histogram(aes(x = x, y = after_stat(density)), col = "black",
		fill = NA, bins = 25) +
	geom_function(fun = d_target, args = list(kappa = kappa, d = d),
		lty = 2, xlim = c(1e-2 - 1, 1 - 1e-2)) +
	ylab("Density") +
	theme_minimal()
```

Plot proposal versus the target on the log-scale.

```{r}
log_h = function(x) { h$d(as.list(x), log = TRUE) }
log_f = function(x) { d_target(x, kappa = kappa, d = d, log = TRUE) }

ggplot() +
	geom_function(fun = log_f) +
	geom_function(fun = log_h, lty = 2) +
	scale_x_continuous(limits = c(1e-2 - 1, 1 - 1e-2)) +
	theme_minimal()
```

# Conclusions

# Acknowledgments {-}

TBD

# References
