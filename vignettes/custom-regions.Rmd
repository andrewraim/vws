---
title: "Custom Regions for VWS Sampling"
author: Andrew Raim, James Livsey, and Kyle Irimata
output:
  rmarkdown::html_vignette:
    number_sections: true
vignette: >
  %\VignetteIndexEntry{custom-regions}
  %\VignetteEncoding{UTF-8}
  %\VignetteEngine{knitr::rmarkdown}
bibliography: references.bib
editor_options: 
  chunk_output_type: console
---

```{r, include = FALSE}
knitr::opts_chunk$set(
	collapse = TRUE,
	comment = "#>",
	prompt = TRUE
)
```

**TBD**

- Add example for VMF maybe...
- Add example for TMVN maybe...

# Introduction

To implement a rejection sampler with the `vws` package, the user must make use
of an existing subclass of `Region` or implement a new one. Two such subclasses
included in the package implement the univariate "constant VWS" method described
by @VWS2024:

- `UnivariateConstRegion`: constant VWS with a continuous support.
- `IntUnivariateConstRegion`: constant VWS with an integer support.

See the manual pages for each sampler for usage and examples. These two regions
are somewhat flexible and can be adapted to a variety of problems. In this
vignette, we will describe the process of coding a customized region. We will
give one univariate example that makes use of the linear VWS method for
improved efficiency, and one multivariate example where the regions go beyond
intervals. To do this, we make use of the [R6](https://r6.r-lib.org) construct
for object-orientation in R.

# A Univariate Linear VWS Sampler

Suppose $X$ has density

\begin{align}
f(x) =
\frac{
(\kappa / 2)^{d/2 - 1} (1 - x^2)^{(d-3)/2} \exp(\kappa x)
}{
\sqrt{\pi} \cdot I_{d/2 - 1}(\kappa) \cdot \Gamma((d-1)/2)
} \cdot \textrm{I}(-1 < x < 1).
\label{eqn:vmf-target}
\end{align}

Let us decompose $f$ into

\begin{align*}
f(x) \propto
\underbrace{(1 - x^2)^{(d-3)/2}}_{w(x)}
\underbrace{\exp(\kappa x) \cdot \textrm{I}(-1 < x < 1)}_{g_0(x)},
\end{align*}

where $w$ is a nonnegative weight function and $g_0$ is proportional to density

\begin{align*}
g(x) = \frac{\kappa e^{\kappa x}}{e^\kappa - e^{-\kappa}} \cdot \textrm{I}(-1 < x < 1).
\end{align*}

Load libraries.

```{r}
library(R6)
library(vws)
```

Check the manual entry for `Region` to see which methods need to be implemented.

```{r, eval=FALSE}
?Region
```

## Operations for Base Distribution

```{r}
log_sinh = function(x) {
	vws::log_sub2_exp(x,-x) - log(2)
}
```

```{r}
d_base = function(x, kappa, log = FALSE) {
	out = kappa*x - log(2) + log(kappa) - log_sinh(kappa) + log(-1 < x & x < 1)
	if (log) { return(out) } else { return(exp(out)) }
}
```

```{r}
p_base = function(x, kappa, d, lower.tail = TRUE, log.p = FALSE) {
	n = length(x)
	islower = rep(lower.tail, n)
	lo = ifelse(islower, rep(-1, n), x)
	hi = ifelse(!islower, rep(1, n), x)
	if (kappa < 0) {
		log_p_lo = log_sub2_exp(-kappa, kappa*lo) - log_sub2_exp(-kappa, kappa)
		log_p_hi = log_sub2_exp(-kappa, kappa*hi) - log_sub2_exp(-kappa, kappa)
	} else {
		log_p_lo = log_sub2_exp(kappa*lo, -kappa) - log_sub2_exp(kappa, -kappa)
		log_p_hi = log_sub2_exp(kappa*hi, -kappa) - log_sub2_exp(kappa, -kappa)
	}
	out = log_sub2_exp(log_p_hi, log_p_lo)
	if (log.p) { return(out) } else { return(exp(out)) }
}
```

```{r}
q_base = function(p, kappa, lower.tail = TRUE, log.p = FALSE) {
	n = length(p)
	if (log.p) { lp = p } else { lp = log(p) }
	if (!lower.tail) { lp = log_sub2_exp(rep(0, n), lp) }

	if (kappa < 0) {
		out = 1/kappa * vws::log_sub2_exp(rep(-kappa,n), lp + log(2) +
			log_sinh(-kappa))
	} else {
		out = 1/kappa * vws::log_add2_exp(rep(-kappa,n), lp + log(2) +
			log_sinh(kappa))
	}
	return(out)
}
```

Normalizing constant.

```{r}
nc_target = function(kappa, d, log = FALSE) {
	out = 0.5*log(base::pi) - (d/2 - 1)*log(kappa / 2) +
		log(besselI(kappa, d/2 - 1)) + lgamma(d/2 - 0.5) -
		log(2) + log(kappa) - log_sinh(kappa)
	if (log) { return(out) } else { return(exp(out)) }
}
```

Density.

```{r}
d_target = function(x, kappa, d, normalize = TRUE, log = FALSE) {
	n = length(x)
	out = rep(-Inf, n)
	idx = which(-1 < x & x < 1)
	out[idx] = 0.5 * (d-3) * log1p(-x[idx]^2) +
		d_base(x[idx], kappa, log = TRUE)
	if (normalize) { out = out - nc_target(kappa, d, log = TRUE) }
	if (log) { return(out) } else { return(exp(out)) }
}
```

CDF.

```{r}
p_target = function(x, kappa, d, lower.tail = TRUE, log.p = FALSE) {
	n = length(x)
	islower = rep(lower.tail, n)
	lo = ifelse(islower, rep(-1, n), x)
	hi = ifelse(!islower, rep(1, n), x)

	out = numeric(n)
	for (i in 1:n) {
		if (lo[i] < hi[i]) {
			int_out = integrate(d_target, lower = lo[i], upper = hi[i],
				kappa = kappa, d = d)
			out[i] = int_out$value
		}
	}
	if (log.p) { return(log(out)) } else { return(out) }
}

```

## Define Class

```{r}
VMFLinearRegion = R6::R6Class(
	classname = "VMFLinearRegion",
	portable = TRUE,
	lock_class = FALSE,
	private = list(
		a = NULL,
		b = NULL,
		dim = NULL,
		kappa = NULL,
		beta0_min = NULL,
		beta1_min = NULL,
		beta0_max = NULL,
		beta1_max = NULL
	)
)
```

## Base Density
Define the base distribution density as a method.

```{r, prompt=FALSE}
VMFLinearRegion$set("public", "d_base", function(x, log = FALSE) {
	out = private$kappa*x - log(2) + log(private$kappa) -
		log_sinh(private$kappa) + log(-1 < x & x < 1)
	if (log) { return(out) } else { return(exp(out)) }
})
```

## Weight Function
Define the weight function as a method.

```{r, prompt=FALSE}
VMFLinearRegion$set("public", "w", function(x, log = FALSE) {
	out = (private$dim - 3) / 2 * log(1 - x^2)
	if (log) { return(out) } else { return(exp(out)) }
})
```

## Generate from Region
Generate random variables from the truncated & reweighted base distribution for
this region.

```{r, prompt=FALSE}
VMFLinearRegion$set("public", "r", function(n) {
	a = private$a
	b = private$b
	kappa = private$kappa
	beta1_max = private$beta1_max

	u = runif(n)
	kappa_j = kappa + beta1_max
	x = vws::q_truncated(u, lo = a, hi = b, pf = p_base, qf = q_base,
		kappa = kappa_j)
	as.list(x)
})
```

## Density for Region
Density for the truncated & reweighted base distribution on this region.

```{r, prompt=FALSE}
VMFLinearRegion$set("public", "d", function(x, log = FALSE) {
	a = private$a
	b = private$b
	kappa = private$kappa
	beta1_max = private$beta1_max

	kappa_j = beta1_max + kappa
	if (kappa_j > 0) {
		out = log(kappa_j) + kappa_j*x -
			vws:::log_sub2_exp(kappa_j*b, kappa_j*a) +
			log(a < x & x <= b)
	} else {
		out = log(-kappa_j) + kappa_j*x -
			vws:::log_sub2_exp(kappa_j*a, kappa_j*b) +
			log(a < x & x <= b)
	}
	if (log) { return(out) } else { return(exp(out)) }
})
```

## Support Indicator
Define the base distribution density as a method.

```{r, prompt=FALSE}
VMFLinearRegion$set("public", "s", function(x) {
	private$a < x & x <= private$b
})
```

## Majorized Weight Function

```{r, prompt=FALSE}
VMFLinearRegion$set("public", "w_major", function(x, log = TRUE) {
	out = rep(-Inf, length(x))
	idx = which(self$s(x))
	out[idx] = private$beta0_max + private$beta1_max*x[idx]
	if (log) { return(out) } else { return(exp(out)) }
})
```

## Bifurcation

```{r, prompt=FALSE}
VMFLinearRegion$set("public", "is_bifurcatable", function() {
	TRUE
})
```

```{r, prompt=FALSE}
VMFLinearRegion$set("public", "bifurcate", function(x = NULL, ...) {
	a = private$a
	b = private$b

	if (is.null(x)) {
		if (is.infinite(a) && is.infinite(a) && a < 0 && b > 0) {
			# Here we have an interval (-Inf, Inf). Make a split at zero.
			x = 0
		} else if (is.infinite(a) && a < 0) {
			# Left endpoint is -Inf. Split based on right endpoint.
			x = b - abs(b) - 1
		} else if (is.infinite(b) && b > 0) {
			# Right endpoint is Inf. Split based on left endpoint.
			x = a + abs(a) + 1
		} else {
			x = (a + b) / 2
		}
	}

	s1 = VMFLinearRegion$new(a, x, private$kappa, private$dim)
	s2 = VMFLinearRegion$new(x, b, private$kappa, private$dim)
	list(s1, s2)
})
```

## Upper and Lower Integrals

```{r, prompt=FALSE}
VMFLinearRegion$set("public", "xi_upper", function(log = TRUE) {
	a = private$a
	b = private$b
	kappa = private$kappa
	beta0_max = private$beta0_max
	beta1_max = private$beta1_max

	kappa_j = beta1_max + kappa
	if (kappa_j > 0) {
		out = log(kappa) + beta0_max - log(2) - log(kappa_j) -
			log_sinh(kappa) + vws::log_sub2_exp(kappa_j*b, kappa_j*a)
	} else {
		out = log(kappa) + beta0_max - log(2) - log(-kappa_j) -
			log_sinh(kappa) + vws::log_sub2_exp(kappa_j*a, kappa_j*b)
	}
	if (log) { return(out) } else { return(exp(out)) }
})
```

```{r, prompt=FALSE}
VMFLinearRegion$set("public", "xi_lower", function(log = TRUE) {
	a = private$a
	b = private$b
	dim = private$dim
	kappa = private$kappa
	beta0_max = private$beta0_max
	beta1_max = private$beta1_max

	lb = p_target(b, kappa, dim, log.p = TRUE)
	la = p_target(a, kappa, dim, log.p = TRUE)
	lnc = nc_target(kappa, dim, log = TRUE)
	out = vws::log_sub2_exp(lb, la) + lnc

	log_xi_upper = self$xi_upper(log = TRUE)

	if (log_xi_upper < out) {
		# This condition can happen numerically. If it occurs, just take lower
		# to be equal to upper.
		out = log_xi_upper
	}
	if (log) { return(out) } else { return(exp(out)) }
})
```

## Print Method

```{r, prompt=FALSE}
VMFLinearRegion$set("public", "description", function() {
	sprintf("(%g, %g]", private$a, private$b)
})
```

```{r, prompt=FALSE}
VMFLinearRegion$set("public", "print", function()
{
	printf("VMF Linear Region (%g, %g]\n", private$a, private$b)
})
```

## Initializer

For this region:

- `w` is assumed to be $(1 - x^2)^(d/3 - 3/2)$
- `g` is assumed to be proportional to $\exp(\kappa x)$
- majorized `w` is assumed to be of the form $\exp(\beta_0 + \beta_1 x)$

Note that `log(w(-1)) = log(w(1)) = Inf` with this choice when `d < 3`. A
workaround is to exclude the endpoints from the support.

```{r, prompt=FALSE}
VMFLinearRegion$set("public", "initialize", function(a, b, kappa, d)
{
	stopifnot(a <= b)
	
	private$a = a
	private$b = b
	private$dim = d
	private$kappa = kappa

	w = self$w

	# First derivative of log-weight function
	d_log_w = function(x) {
		-(d-3) * x / (1 - x^2)
	}

	# MGF the truncated and reweighted g
	mgf = function(s, log = FALSE)  {
		if ((s + kappa) >= 0) {
			out = log(kappa) - log(s + kappa) +
				log_sub2_exp((s + kappa) * b, (s + kappa) * a) -
				log_sub2_exp(kappa * b, kappa * a)
		} else {
			out = log(kappa) - log(-(s + kappa)) +
				log_sub2_exp((s + kappa) * a, (s + kappa) * b) -
				log_sub2_exp(kappa * b, kappa * a)
		}
		if (log) { return(out) } else { return(exp(out)) }
	}

	obj_line = function(x) {
		w(x, log = TRUE) - x * d_log_w(x) + mgf(x, log = TRUE)
	}

	# Determine if log(w(x)) is convex, concave, or a constant. Majorization
	# and minorization choices will depend on this.
	if (d > 3) {
		# log(w(x)) is concave. Any tangent line will lie above the curve.

		# For the majorizer
		optim_out = optimize(f = obj_line, interval = c(a, b), maximum = FALSE)
		c_star = optim_out$minimum
		beta0_max = w(c_star) - c_star*d_log_w(c_star)
		beta1_max = d_log_w(c_star)

		# For the minorizer
		A = matrix(c(1,1,a,b), 2, 2)
		c = c(w(a), w(b))
		x = solve(A, c)
		beta0_min = x[1]
		beta1_min = x[2]
	} else if (d < 3) {
		# log(w(x)) is convex. Make a line that passes through a and b.

		# For the majorizer
		A = matrix(c(1,1,a,b), 2, 2)
		c = c(w(a), w(b))
		x = solve(A, c)
		beta0_max = x[1]
		beta1_max = x[2]

		# For the minorizer
		optim_out = optimize(f = obj_line, interval = c(a, b), maximum = TRUE)
		c_star = optim_out$maximum
		beta0_min = w(c_star) - c_star*d_log_w(c_star)
		beta1_min = d_log_w(c_star)
	} else {
		# log(w(x)) is constant with value zero
		beta0_max = 0
		beta1_max = 0
		beta0_min = 0
		beta1_min = 0
	}

	private$beta0_max = beta0_max
	private$beta1_max = beta1_max
	private$beta0_min = beta0_min
	private$beta1_min = beta1_min
})
```

## Try it Out

TBD: looks like there are still bugs in here. Results aren't correct. We saw a
much better acceptance rate in the other (messy) version of the code.

```{r}
support = VMFLinearRegion$new(a = 1e-4 - 1, b = 1 - 1e-4, kappa = 0.1, d = 2)

# Adapt the proposal
h_init = fmm_proposal(list(support))
adapt_out = adapt_midpoint(h_init, N = 100, control = rejection_control(report = 20))
h = adapt_out$h

# Generate draws
control = rejection_control(max_rejects = 10000, action_incomplete = "message")
out = rejection(h, n = 10000, control = control)
out |> unlist() |> hist()

x = seq(-1, 1, length.out = 100)
log_h0x = h$d(x |> as.list(), normalize = TRUE, log = TRUE)
plot(x, log_h0x)
```

# References
